package com.sigmoid.gravity.common.sequence;

import java.util.concurrent.atomic.AtomicLong;

public abstract class SequenceGenerator {

    private static final int MAX_ID_COUNT_PER_CALL = 10000;

    private int powOf2(int exp) {
        return 1 << exp;
    }

    //generated by snowflake-like algorithm
    //1 bit - reserved
    //41 bits - low bits for timestamp
    //10 bits - node id
    //12 bits - ticker
    //support up to 4096 different ids within 1 millisecond
    private AtomicLong ticker = new AtomicLong(-1L);

    //masks
    private long tickerMask = powOf2(12) - 1;
    private long nodeMask = (powOf2(10) - 1) << 12;
    private long timestampMask = (powOf2(41) - 1) << 22;

    //node id
    private long maskedNodeId;

    public abstract long initNodeId();

    public SequenceGenerator() {
        this.maskedNodeId = (initNodeId() << 12) & nodeMask;
    }

    private long currentId() {
        long result = 0;
        result |= ((ticker.get()) & tickerMask);
        result |= maskedNodeId;
        result |= (System.currentTimeMillis() << 22) & timestampMask;
        return result;
    }

    private long nextId() {
        long result = 0;
        result |= ((ticker.incrementAndGet()) & tickerMask);
        result |= maskedNodeId;
        result |= (System.currentTimeMillis() << 22) & timestampMask;
        return result;
    }

    public long generateId() {
        long currentId = currentId();
        while (true) {
            long nextId = nextId();
            if (nextId > currentId) {
                return nextId;
            }
        }
    }

    public long[] generateIds(int count) {

        if (count > MAX_ID_COUNT_PER_CALL) {
            //TODO define exception class
            throw new RuntimeException(String.format("Id request count overflow, max count is [%d]", MAX_ID_COUNT_PER_CALL));
        }

        int n = 0;
        long currentId = currentId();
        long[] results = new long[count];
        while (n < count) {
            long nextId = nextId();
            if (nextId > currentId) {
                results[count++] = nextId;
                currentId = nextId;
            }
        }
        return results;

    }

}
